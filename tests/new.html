<!-- new.html -->
<!DOCTYPE html>
<meta charset="utf-8">

<head>

  <!-- Leaflet CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>

  <!-- TopoJSON for loading polygon data more efficiently than GeoJSON -->
  <script type="text/javascript" src="https://d3js.org/topojson.v1.min.js"></script>

  <!-- D3, jQuery, lodash -->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
  
  <!-- Local Javascript -->
  <!-- <script src="./index.js"></script> -->
  <link rel="stylesheet" href="new.css" type="text/css" media="all" />

  <!-- select2, a select box enhancer for jquery -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/css/select2.min.css" rel="stylesheet" />
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/js/select2.min.js"></script>

  <!-- fonts/ -->
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">


</head>

<body>

  <div style="margin:1em;">
    <!-- <button onClick="draw(nest(rawdata,'variable'))">Switch to data by variable</button> -->
    <!-- <button onClick="draw(nest(rawdata,'theme'))">Switch to data by theme</button> -->
    <button style="margin-right:4px;" onClick="draw(nest(rawdata, curr_field, {key:'strength',value:'Direct correlation'}),d3.select('svg.top'))">Filter by strength</button>

    <select id="country" required>
      <option value="" disabled selected>Select a country</option>
    </select>

  </div>

  <script>

  // global declarations

  // data variables
  var rawdata;
  var countrylist;

  // row heights and widths, rectangle withs
  var rowh = 55;
  var subh = 20;
  var subw = 300;
  var rectw = 20;

  // register events to emit & listen for via d3 dispatch
  var dispatch = d3.dispatch("load", "statechange");

  // get data and a callback when download is complete
  d3.queue()
      .defer(d3.csv, 'data/countries.csv')
      .defer(d3.csv, 'data/data.csv')
      .await(main);
  
  function main(error, countries, data) {
    if (error) throw error;
    
    // parse country data
    countries = countries.map(function(d) {
      return {
        lat: +d.latitude,
        lon: +d.longitude,
        abrev: d.country,
        count: 0,
        name: d.name
      }
    });
    
    // data setup
    var countries = [];
    data.forEach(function(d) {
      // transform string valence into intenger
      d.valence = +d.valence;
      // generate list of countries present in data
      // d.country can be a list of countries, so check for that, and split if so
      var country = d.country;
      country = country.indexOf(",") ? country.split(",") : [country];
      countries = _.union(countries, country.map(function(c) { return c.trim() }));
    });
    countries = _.without(_.uniq(countries.sort()), "");
    countries.forEach(function(country) {
      d3.select("select#country")
        .append("option")
        .text(country)
        .attr("value",country.trim())
    });
    
    // keep a global references to raw data
    rawdata = data;
    countrylist = countries;

    // nest the data based on a given attribute
    var nested = nest(data,"theme",false);

    // construct a new d3 map, not as in geographic map, but more like a "hash"
    // TA Interesting structure, not sure if we'll use it here or not
    var map = d3.map(nested, function(d) { return d.key; });

    // call our dispatch events with `this` context, and corresponding data
    dispatch.call("load", this, map);
    
    // ulimately we want to get all the data, not a subset
    // TO DO: what version of data gets dispatched?
    // console.log(nested[0]);
    // dispatch.call("statechange", this, map);
    dispatch.call("statechange", this, nested);

  }

  // register a listener for "load" and create a dropdown / select elem
  // TO DO: this is quite different from the CH example,
  // for now simply ignoring "map" and loading the global countries array
  dispatch.on("load.menu", function(countries) {
    // add listener to select#country that calls "statechange"
    var select = d3.select("select#country")
      .on("change", function() {
        var site = this.value;
        dispatch.call(
          "statechange",
          this,
          // TO DO: update for the country filter use case
          // map.get(site)
          nest(rawdata,"theme",{key: "country", value: site})
        );
    });

    // append options to select dropdown
    select.selectAll("option")
        .data(countrylist)
      .enter().append("option")
        .attr("value", function(d) { return d; })
        .text(function(d) { return d; });

    // set the current dropdown option to value of last statechange
    // ## TA TODO we don't actually want to trigger change yet on this
    //     dont think this is relevant  at the moment
    // dispatch.on("statechange.menu", function(site) {
    //   debugger;
    //   select.property("value", site.key);
    // });

    // hack: style the dropdown using Select2, then show
    // $("select#country").select2({
    //   placeholder: "Select a country",
    //   minimumResultsForSearch: Infinity
    // }).show();

  }); // load.menu

  // inital chart setup after data load
  dispatch.on("load.chart", function(map) {
    // layout properties
    var margin = { top: 50, right: 30, bottom: 30, left: 250 };
    var width = 800 - margin.left - margin.right;
    var innerHeight = 100;
    var height = 500; // TO DO: This will vary considerably between upper and lower charts

    // 
    // INNER SCALES AND AXES
    //
    var yScaleInner = d3.scalePoint().padding(0.5); // ordinal scale for Y, these are simply category labels
    var xScaleInner = d3.scaleLinear(); // x direction is fixed width, from 0 to max > TO DO 

    // set up yScaleInner, 
    yScaleInner
      .range([0, innerHeight])
      .domain(["plus", "minus"]);

    // domain for our x scale 0 to max, in our simplified case about 60
    // (note, we have no need to display the ticks, labels, ever)
    // (also important to note that the client wants these to overflow in narrow cols)
    xScaleInner
      .range([0, width])
      .domain([0, 60]);

    // d3.v4 method of setting up axes: axisLeft, axisBottom, etc.
    var yAxisInner = d3.axisLeft()
      .scale(yScaleInner);

    var xAxisInner = d3.axisBottom()
      // .ticks(0) TO DO ??
      .scale(xScaleInner);

    // 
    // OUTER SCALES AND AXES
    //
    var yScaleOuter = d3.scalePoint().padding(0.5); 
    var xScaleOuter = d3.scaleLinear(); 

    yScaleOuter
      .domain(map.keys())
      .range([0, height])

    // domain for our x scale 0 to max, in our simplified case about 60
    // (note, we have no need to display the ticks, labels, ever)
    // (also important to note that the client wants these to overflow in narrow cols)
    xScaleOuter
      .range([0, width])
      .domain([0, 150]);

    // d3.v4 method of setting up axes: axisLeft, axisBottom, etc.
    var yAxisOuter = d3.axisLeft()
      .scale(yScaleOuter);

    var xAxisOuter = d3.axisBottom()
      // .ticks(0) TO DO ??
      .scale(xScaleOuter);

    // INITIAL SVG SETUP
    // create an svg element to hold our chart parts
    var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + [margin.left, margin.top] + ")")
        .attr("class","outergroup")


    // define a transition, will occur over 750 milliseconds
    var t = svg.transition().duration(750);


    // register a callback to be invoked which updates the chart when "statechange" occurs
    dispatch.on("statechange.chart", function(data) {
// initial switch: temporarily test a single row
// var data = data.get("ENV"); // if using map OR
// var data = data[0]; // if using nested 
console.log("statechange data: ", data);

      // update our yScaleInner
      // NOTE: we don't really change range for either, always showing single units of n by n dims
      // yScaleInner.domain(data.values.map(function(d) { return d.key; }).sort());
      // yAxisInner.scale(yScaleInner);
      // t.select("g.y.axis").call(yAxis); // this helps show whats happening, but not needed

      // bind our new piece of data to our svg element
      // could also do `svg.data([data.values]);`
      svg.datum(data);  

      // OUTER AXES
      // append svg groups for the axes, then call their corresponding axis function
      svg.append("g")
        .attr("class", "y axis")
        .call(yAxisOuter);

      // create svg groups for each data grouping (the top level of nest())
      var rows = svg.selectAll("g.row")
        .data(function(d) {return d}, function(d) {return d.key});

      // remove old
      rows.exit().remove();

      // update existing ones left over
      rows.attr("class", "row")
        .attr("transform", function(d) {
          return "translate(50," + yScaleOuter(d.key) + ")"
        });

      // create new ones if our updated dataset has more then the previous
      rows.enter().append("g")
        .attr("class", "row")
        .attr("transform", function(d) {
          return "translate(50," + yScaleOuter(d.key) + ")"
        });


      // INNER AXES
      // same select-again issue as below?  appears to be so
      var rows = svg.selectAll("g.row")
      // append svg groups for the axes, then call their corresponding axis function
      rows.append("g")
        .attr("class", "y axis")
        .call(yAxisInner);

      // never turns up?
      rows.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxisInner);

      // tell d3 we want svg groups for each of our chart categories
      // there are currently only two: plus and minus
      var charts = rows.selectAll("g.chart")
        .data(function(d) { return d.values; }, function(d) {return d.key});

      // get rid of the old ones we don't need when doing an update
      charts.exit().remove();

      // update existing ones left over
      charts.attr("class", "chart")
        .attr("transform", function(d) {
          return "translate(0," + yScaleInner(d.key) + ")"
        });

      // create new ones if our updated dataset has more then the previous
      charts.enter().append("g")
        .attr("class", "chart")
        .attr("transform", function(d) {
          return "translate(0," + yScaleInner(d.key) + ")"
        });

      // reselect the chart groups, so that we get any new ones that were made
      // our previous selection would not contain them
      charts = rows.selectAll("g.chart");

      // bind data
      var squares = charts.selectAll("rect")
        .data(function(d) { return d.values; });

      // get rid of ones we don't need anymore, fade them out
      squares.exit()
        .transition(t)
        .style("opacity", 1e-6)
        .remove();

      // update existing squares, transition size & fill
      squares
        .style("fill-opacity", 1)
        .transition(t)
        .attr("x",function(d, i) { return i * rectw})

      // make new squares
      squares.enter().append("rect")
        .attr("x",function(d, i) { return i * rectw})
        .classed("neutral",function(d) { return d.valence == 0 })
        .classed("plus",function(d) { return d.valence > 0 })
        .classed("minus",function(d) { return d.valence < 0 })
        .classed("weak", function(d) {return d.strength != "Direct correlation" ? true : false});

    }); // statechange.chart

  }); // load.chart




  // UTILITY FUNCTIONS

  // nest our data on selected field, then either "plus" or "minus",
  //   depending on value of "valence"
  // optionally pass a filter object in the form of 
  //   {key: "fieldname to filter", value: "value to match"}
  function nest(data,field,filter) {
    if (filter) {
      data = data.filter(function(d) {
        // country requires more permissive filtering (match one country in a list)
        return filter.key == "country" ? d["country"].indexOf(filter.value) > -1  : d[filter.key] == filter.value
      })
    }

    return d3.nest()
        .key(function(d) { return d[field] })
        .key(function(d) {  if (d.valence > 0) { return 'plus'; } return 'minus'; }).sortKeys(d3.descending)
        .entries(data);
  
  } // nest




  </script>

</body>

</html>

