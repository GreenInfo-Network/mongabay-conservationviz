<!-- new.html -->
<!DOCTYPE html>
<meta charset="utf-8">

<head>

  <!-- Leaflet CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>

  <!-- TopoJSON for loading polygon data more efficiently than GeoJSON -->
  <script type="text/javascript" src="https://d3js.org/topojson.v1.min.js"></script>

  <!-- D3, jQuery, lodash -->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
  
  <!-- Local Javascript -->
  <!-- <script src="./index.js"></script> -->
  <link rel="stylesheet" href="new.css" type="text/css" media="all" />

  <!-- select2, a select box enhancer for jquery -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/css/select2.min.css" rel="stylesheet" />
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/js/select2.min.js"></script>

  <!-- fonts/ -->
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">


</head>

<body>

  <div style="margin:1em;">
    <!-- <button onClick="draw(nest(rawdata,'variable'))">Switch to data by variable</button> -->
    <!-- <button onClick="draw(nest(rawdata,'theme'))">Switch to data by theme</button> -->
    <button style="margin-right:4px;" onClick="draw(nest(rawdata, curr_field, {key:'strength',value:'Direct correlation'}),d3.select('svg.top'))">Filter by strength</button>

    <select id="country" required>
      <option value="" disabled selected>Select a country</option>
    </select>

  </div>

  <svg class="top"></svg>

  <script>

  // global declarations

  // data variables
  var rawdata;
  var countrylist;

  // row heights and widths, rectangle withs
  var rowh = 55;
  var subh = 20;
  var subw = 300;
  var rectw = 20;

  // register events to emit & listen for via d3 dispatch
  var dispatch = d3.dispatch("load", "statechange");

  // get data and a callback when download is complete
  d3.queue()
      .defer(d3.csv, 'data/countries.csv')
      .defer(d3.csv, 'data/data.csv')
      .await(main);
  
  function main(error, countries, data) {
    if (error) throw error;
    
    // parse country data
    countries = countries.map(function(d) {
      return {
        lat: +d.latitude,
        lon: +d.longitude,
        abrev: d.country,
        count: 0,
        name: d.name
      }
    });
    
    // data setup
    var countries = [];
    data.forEach(function(d) {
      // transform string valence into intenger
      d.valence = +d.valence;
      // generate list of countries present in data
      // d.country can be a list of countries, so check for that, and split if so
      var country = d.country;
      country = country.indexOf(",") ? country.split(",") : [country];
      countries = _.union(countries, country.map(function(c) { return c.trim() }));
    });

    countries = _.without(_.uniq(countries.sort()), "");
    console.log(countries);

    countries.forEach(function(country) {
      d3.select("select#country")
        .append("option")
        .text(country)
        .attr("value",country.trim())
    });
    
    // keep a global references to raw data
    rawdata = data;
    countrylist = countries;

    // nest the data based on a given attribute
    var nested = nest(data,"theme",false);

    // construct a new d3 map, not as in geographic map, but more like a "hash"
    // TA Interesting structure, not sure if we'll use it here or not
    var map = d3.map(nested, function(d) { return d.key; });

    // call our dispatch events with `this` context, and corresponding data
    dispatch.call("load", this, map);
    // ulimately we want to get all the data, not a subset
    // for now, send off the map and select as needed below
    dispatch.call("statechange", this, map);

  }

  // register a listener for "load" and create a dropdown / select elem
  // TO DO: this is quite different from the CH example,
  // for now simply ignoring "map" and loading the global countries array
  dispatch.on("load.menu", function(countries) {
    // add listener to select#country that calls "statechange"
    var select = d3.select("select#country")
      .on("change", function() {
        var site = this.value;
        dispatch.call(
          "statechange",
          this,
          // TO DO: update for the country filter use case
          // map.get(site)
          // TODO - filter data by country etc.
        );
    });

    // append options to select dropdown
    select.selectAll("option")
        .data(countrylist)
      .enter().append("option")
        .attr("value", function(d) { return d; })
        .text(function(d) { return d; });

    // set the current dropdown option to value of last statechange
    // ## TA TODO we don't actually want to trigger change yet on this
    // dispatch.on("statechange.menu", function(site) {
    //   select.property("value", site.key);
    // });

    // hack: style the dropdown using Select2, then show
    $("select#country").select2({
      placeholder: "Select a country",
      minimumResultsForSearch: Infinity
    }).show();

  }); // load.menu

  // inital chart setup after data load
  dispatch.on("load.chart", function(map) {
    // layout properties
    var margin = { top: 20, right: 30, bottom: 30, left: 120 };
    var width = 800 - margin.left - margin.right;
    var height = 500 - margin.top - margin.bottom;

    // scales for x and y axes
    var yScale = d3.scalePoint().padding(0.5); // ordinal scale for Y, these are simply category labels
    var xScale = d3.scaleLinear(); // x direction is fixed width, from 0 to max > TO DO 

    // set up yScale, TO DO, this can vary considerably, depending on group
    // and responsive layout (mobile v desktop) 
    yScale
      .range([0, height])
      .round(true);

    // domain for our x scale 0 to max, in our simplified case about 60
    // (note, we have no need to display this, ever)
    // (also important to note that the client wants these to overflow in narrow cols)
    xScale
      .range([0, width])
      .domain([0, 60]);

    // d3.v4 method of setting up axises: axisLeft, axisBottom, etc.
    var yAxis = d3.axisLeft()
      .scale(yScale);

    var xAxis = d3.axisBottom()
      .ticks(0)
      .scale(xScale);

    // create an svg element to hold our chart parts
    var svg = d3.select("body").append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .append('g')
        .attr('transform', 'translate(' + [margin.left, margin.top] + ')')

    // append svg groups for the axises, then call their corresponding axis function
    svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);

    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);



    // register a callback to be invoked which updates the chart when "statechange" occurs
    dispatch.on("statechange.chart", function(site) {
      // our transition, will occur over 750 milliseconds
      var t = svg.transition().duration(750);

// initial switch: temporarily test a single row
var site = site.get("ENV");
console.log("statechange data: ", site);

      // update our yScale & transition the yAxis, note the xAxis doesn't change
      yScale.domain(site.values.map(function(d) { return d.key; }).sort());
      yAxis.scale(yScale);
      t.select("g.y.axis").call(yAxis);

      // bind our new piece of data to our svg element
      // could also do `svg.data([site.values]);`
      svg.datum(site.values); 

            // tell d3 we want svg groups for each of our gen categories
      var charts = svg.selectAll("g.chart")
        .data(function(d) { return d; });

      // get rid of the old ones we don't need when doing an update
      charts.exit().remove();

      // update existing ones left over
      charts.attr("class", "chart")
        .attr("transform", function(d) {
          return "translate(0," + yScale(d.key) + ")"
        });

      // create new ones if our updated dataset has more then the previous
      charts.enter().append("g")
        .attr("class", "chart")
        .attr("transform", function(d) {
          return "translate(0," + yScale(d.key) + ")"
        });

      // reselect the gen groups, so that we get any new ones that were made
      // our previous selection would not contain them
      charts = svg.selectAll("g.chart");

      // tell d3 we want some squares!
      var squares = charts.selectAll("rect")
        .data(function(d) { return d.values; });

      // get rid of ones we don't need anymore, fade them out
      squares.exit()
        .transition(t)
        .style("opacity", 1e-6)
        .remove();

      // update existing squares, transition size & fill
      squares
        .style("fill-opacity", 1)
        .transition(t)
        .attr("x",function(d, i) { return i * rectw})

      // make new squares
      squares.enter().append("rect")
        .attr("x",function(d, i) { return i * rectw})
        .classed("neutral",function(d) { return d.valence == 0 })
        .classed("plus",function(d) { return d.valence > 0 })
        .classed("minus",function(d) { return d.valence < 0 })
        .classed("weak", function(d) {return d.strength != "Direct correlation" ? true : false});







    }); // statechange.chart

  }); // load.chart




  // UTILITY FUNCTIONS

  // nest our data on selected field, then either "plus" or "minus",
  //   depending on value of "valence"
  // optionally pass a filter object in the form of 
  //   {key: "fieldname to filter", value: "value to match"}
  function nest(data,field,filter) {
    if (filter) {
      data = data.filter(function(d) {
        // country requires more permissive filtering (match one country in a list)
        return filter.key == "country" ? d["country"].indexOf(filter.value) > -1  : d[filter.key] == filter.value
      })
    }

    return d3.nest()
        .key(function(d) { return d[field] })
        .key(function(d) {  if (d.valence > 0) { return 'plus'; } return 'minus'; }).sortKeys(d3.descending)
        .entries(data);
  
  } // nest




  </script>

</body>

</html>

